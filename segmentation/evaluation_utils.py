import numpy as np
import matplotlib.pyplot as plt
import os
from typing import List
from data_tooling.utils.files_utils import read_listing_file
from scipy import interpolate

#matplotlib shorthands of colors
colors_list = ['r', 'b', 'g', 'y', 'c', 'm', 'k']


def clean_array(array):
    """
    Method strictly used for evaluation data generated by evaluation on cross-validation process. Project should be
    refactored such that this method is not needed:
        - in the first iteration, as training set size is small, an approximation of a percentage of the
        size that is not an exact divisor of the size will yield a split consisting of more parts that
        the splits of subsequent iterations (example: 7 // 5 = 1 => split in 7, 10 //5 = 2 => split in 5)
        which causes different iterations to have more metric values as the other ones.
        - this method will even-out the constituent arrays of the cross-validation process, cropping them
        such that at the end all the iterations have the same number of elements (equal to the shortest one)

    Args:
         array: list of lists of metric elements
    Return:
        nparray: numpy array in which sub-arrays have equal length
    """

    min_len = min([len(line) for line in array])

    nparray = np.array([np.array(line[:min_len], dtype=float) for line in array])
    return nparray


def read_segmentation_data_cross(filename: str):
    """
    Method to read data from an evaluation file as defined by the cross-validation process's evaluation function
    Sample input looks like:
    loss acc;loss acc;loss acc ... ;loss acc;   # <- iteration 1 of active-learning process, ';' splits diff cross-val iters
    loss acc;loss acc;loss acc ... ;loss acc;   # <- iteration 2
    .
    .
    .
    loss acc;loss acc;loss ac ... ;loss acc;    # <- iteration n

    Args:
        filename: path to evaluation data text file
    Return:
        data: array (each AL iteration) of arrays (each CV iteration) of dicts (CV iteration data, i.e.: loss, acc)
    """
    data = []
    lines = read_listing_file(filename)

    for line in lines:
        iter_data = [{'loss': v.split(' ')[0], 'acc': v.split(' ')[1]} for v in line.split(';')[:-1]]
        data.append(iter_data)

    return data

def read_segmentation_data_simple(filename: str):
    """
        Method to read data from an evaluation file as defined by the simple process's evaluation function
        Sample input looks like:
        loss acc;loss acc;loss acc ... ;loss acc;   # ';' splits diff AL iters
        loss acc;loss acc;loss acc ... ;loss acc;   # ';' maybe a second exp to average

        Args:
            filename: path to evaluation data text file
        Return:
            data: array (each AL iteration) of dicts (CV iteration data, i.e.: loss, acc)
        """

    lines = read_listing_file(filename)

    diff_exp_data = None
    for line in lines:
        data = [{'loss': float(v.split(' ')[0]),
                 'acc': float(v.split(' ')[1]),
                 'acc2': float(v.split(' ')[2])} for v in line.split(';')[:-1]]
        if diff_exp_data is None:
            diff_exp_data = data
        else:
            #crop data to len of shorter one:
            if len(diff_exp_data) < len(data):
                data = data[:len(diff_exp_data)]
            else:
                diff_exp_data = diff_exp_data[:len(data)]
            diff_exp_data = [{k: d_new[k] + d_old[k] for k in d_old.keys()} for d_old, d_new in zip(diff_exp_data, data)]


    #average data in the list

    data = [{k: d[k] / len(lines) for k in d.keys()} for d in diff_exp_data]

    return data

def plot_cross_graph_from_array(metric_lists: list, metric_name: str, experiment_name: str, color: str = "b",
                                conf_interval: float = 0.95, show: bool = True):
    """
    Plots a graph of a complete AL with cross-validation process, along with confidence interval yielded
    Args:
        metric_lists: list of lists of metric values. Each sublist represents an AL iteration, each element of
                      the sublists represents a single metric value for the target process (e.g.: "acc")
        metric_name: the name of the metric to plot - only used to be written on the graph for clarity
        experiment_name: the name of the experiment - only used to be written on the legend for clarity
        color: the color with which the plot will be shown
        conf_interval: the desired confidence interval to be highlighted on the plot
        show: whether the plot drawn to be displayed on screen or just kept for further additions of other plots
    """

    means = np.mean(metric_lists, axis=1)
    stds = np.std(metric_lists, axis=1)

    # Calculate the confidence interval
    n = len(metric_lists[0])
    ci = conf_interval * stds / np.sqrt(n)

    # Create the x-axis for the plot
    iterations = range(1, len(metric_lists) + 1)


    # Plot the mean values
    plt.plot(iterations, means, color + 'o-', label=experiment_name)

    # Plot the confidence intervals
    plt.fill_between(iterations, means - ci, means + ci, color=color, alpha=0.2)

    plt.xlabel('Iteration')
    plt.ylabel(metric_name)
    plt.legend(loc='best')

    # Show the plot
    if show:
        plt.show()

def plot_simple_graph_from_array(metric_list: list, metric_name: str, experiment_name: str,
                                 color: str = "b", show: bool = True):
    """
    Plots a graph of a complete AL simple process results
    Args:
        metric_list: list of metric values to be plotted
        metric_name: the name of the metric to plot - only used to be written on the graph for clarity
        experiment_name: the name of the experiment - only used to be written on the legend for clarity
        color: the color with which the plot will be shown
        show: whether the plot drawn to be displayed on screen or just kept for further additions of other plots
    """
    # Create the x-axis for the plot
    iterations = range(1, len(metric_list) + 1)

    # Plot the metric values
    x_dense = np.linspace(1, len(metric_list) + 1, len(metric_list)//3)
    bspline = interpolate.make_smoothing_spline(iterations, metric_list)
    y_smooth = bspline(iterations)

    plt.plot(iterations, y_smooth, color, label=experiment_name)

    plt.xlabel('Iteration')
    plt.ylabel(metric_name)
    plt.legend(loc='best')

    # Show the plot
    if show:
        plt.show()

def plot_cross_graph_from_file(filename: str, metric_name: str, experiment_name: str, color: str = "b",
                               conf_interval: float = 0.95, show: bool = True):
    """
    Plots a graph of a complete AL with cross-validation process, along with confidence interval yielded, with experiment
    data given from a file that has to be pre_processed
    Args:
        filename: the path to the text file holding the evaluation data
        metric_name: the name of the metric to plot - only used to be written on the graph for clarity
        experiment_name: the name of the experiment - only used to be written on the legend for clarity
        color: the color with which the plot will be shown
        conf_interval: the desired confidence interval to be highlighted on the plot
        show: whether the plot drawn to be displayed on screen or just kept for further additions of other plots
    """
    data = read_segmentation_data_cross(filename)
    metric_only = [[cv_iter[metric_name] for cv_iter in al_iter] for al_iter in data]

    metric_only = clean_array(metric_only)

    plot_cross_graph_from_array(metric_lists=metric_only, metric_name=metric_name, experiment_name=experiment_name,
                                color=color, conf_interval=conf_interval, show=show)

def plot_simple_graph_from_file(filename: str, metric_name: str, experiment_name: str,
                                color: str = "b", show: bool = True):
    """
    Plots a graph of a complete AL with simple process, with experiment
    data given from a file that has to be pre_processed
    Args:
        filename: the path to the text file holding the evaluation data
        metric_name: the name of the metric to plot - only used to be written on the graph for clarity
        experiment_name: the name of the experiment - only used to be written on the legend for clarity
        color: the color with which the plot will be shown
        show: whether the plot drawn to be displayed on screen or just kept for further additions of other plots
    """
    data = read_segmentation_data_simple(filename)

    metric_only = [float(al_iter[metric_name]) for al_iter in data]

    plot_simple_graph_from_array(metric_list=metric_only, metric_name=metric_name, experiment_name=experiment_name,
                                color=color, show=show)


def compare_cross_graphs(experiments_filenames: List[str], experiments_names: List[str], metric_name: str,
                         conf_interval: float = 0.95):
    """
        Method which plots multiple graphs on the same image for a comparative view. Will randomly assign colors
        to different experiments for differentiation
        Args:
            experiments_filenames: the paths to each of the text files holding the evaluation data
            metric_name: the name of the metric to plot - only used to be written on the graph for clarity
            experiments_names: the names of each of the experiments - only used to be written on the legend for clarity
            conf_interval: the desired confidence interval to be highlighted on the plot
    """
    colors = colors_list[:len(experiments_names)]
    for name, filename, color in zip(experiments_names, experiments_filenames, colors):
        plot_cross_graph_from_file(filename, metric_name, name, color, conf_interval, show=False)

    plt.show()

def compare_simple_graphs(experiments_filenames: List[str], experiments_names: List[str], metric_name: str, save_path: str =None):
    """
        Method which plots multiple graphs on the same image for a comparative view. Will randomly assign colors
        to different experiments for differentiation
        Args:
            experiments_filenames: the paths to each of the text files holding the evaluation data
            metric_name: the name of the metric to plot - only used to be written on the graph for clarity
            experiments_names: the names of each of the experiments - only used to be written on the legend for clarity
    """

    colors = colors_list[:len(experiments_names)]
    for name, filename, color in zip(experiments_names, experiments_filenames, colors):
        plot_simple_graph_from_file(filename, metric_name, name, color, show=False)

    plt.show()

    if save_path is not None:
        plt.savefig(save_path)
